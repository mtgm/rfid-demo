<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>RFID 3D Konfigüratör</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{margin:0;background:#f3f0ea;color:#0b0d12;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;display:flex;flex-direction:column;min-height:100vh}
    header{padding:10px 16px;border-bottom:1px solid #d9d2c7;background:#ffffffcc;backdrop-filter:saturate(1.2) blur(2px);display:flex;align-items:center;gap:16px}
    header h1{font-size:16px;margin:0;font-weight:600}
    #viewer{flex:1;position:relative;min-height:360px}
    #canvasContainer{position:absolute;inset:0}
    .toolbar{padding:12px 16px;border-top:1px solid #d9d2c7;background:#ffffffcc;backdrop-filter:saturate(1.2) blur(2px);display:flex;gap:12px;flex-wrap:wrap}
    .card{border:1px dashed #c7b9a4;border-radius:10px;padding:10px 12px;background:#fff;display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{border:1px solid #c7b9a4;background:#fff;color:#2b2b2b;padding:6px 10px;border-radius:8px;cursor:pointer}
    .btn:hover{background:#f4efe8}
    .input{border:1px solid #c7b9a4;background:#fff;color:#2b2b2b;padding:6px 10px;border-radius:8px}
    .range{width:180px}
    .diag{position:absolute;left:12px;bottom:12px;background:#ffffffdd;border:1px solid #c7b9a4;border-radius:8px;padding:6px 10px;font-size:12px;max-width:80vw;white-space:pre-wrap}
    .mini{font-size:12px;opacity:.75}
  </style>

  <!-- Import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js?v=15"
    }
  }
  </script>
</head>
<body>
  <header><h1>RFID 3D Konfigüratör</h1></header>

  <div id="viewer">
    <div id="canvasContainer"></div>
    <div id="diag" class="diag">Hazır.</div>
  </div>

  <div class="toolbar">
    <!-- MODEL SEÇ: Yeni eklendi -->
    <div class="card">
      <div class="row"><strong>Model Seç</strong></div>
      <div class="row">
        <button class="btn" id="modelA">Model A</button>
        <button class="btn" id="modelB">Model B</button>
      </div>
      <div class="mini">assets/model.glb ve assets/model2.glb yükleyin.</div>
    </div>

    <div class="card">
      <div class="row"><strong>UID Girişi</strong></div>
      <div class="row">
        <input id="uidInput" class="input" placeholder="ör. 0001234567" />
        <button id="applyUid" class="btn">Uygula</button>
      </div>
    </div>

    <div class="card">
      <div class="row"><strong>ALT PANEL</strong></div>
      <div class="row">
        <button class="btn" data-part="alt_panel" data-mat="walnut">Ceviz</button>
        <button class="btn" data-part="alt_panel" data-mat="oak">Meşe</button>
        <button class="btn" data-part="alt_panel" data-mat="white">Beyaz</button>
      </div>
    </div>

    <div class="card">
      <div class="row"><strong>ÜST PANEL</strong></div>
      <div class="row">
        <button class="btn" data-part="ust_panel" data-mat="walnut">Ceviz</button>
        <button class="btn" data-part="ust_panel" data-mat="oak">Meşe</button>
        <button class="btn" data-part="ust_panel" data-mat="white">Beyaz</button>
      </div>
    </div>

    <div class="card">
      <div class="row"><strong>SOL PANEL</strong></div>
      <div class="row">
        <button class="btn" data-part="sol_panel" data-mat="walnut">Ceviz</button>
        <button class="btn" data-part="sol_panel" data-mat="oak">Meşe</button>
        <button class="btn" data-part="sol_panel" data-mat="white">Beyaz</button>
      </div>
    </div>

    <div class="card">
      <div class="row"><strong>SAĞ PANEL</strong></div>
      <div class="row">
        <button class="btn" data-part="sag_panel" data-mat="walnut">Ceviz</button>
        <button class="btn" data-part="sag_panel" data-mat="oak">Meşe</button>
        <button class="btn" data-part="sag_panel" data-mat="white">Beyaz</button>
      </div>
    </div>

    <!-- Dinamik Doku Ayarı -->
    <div class="card" style="min-width:280px">
      <div class="row"><strong>Doku Ayarları (Dinamik)</strong></div>
      <div class="row">
        <label class="mini">Parça:</label>
        <select id="partSel" class="input">
          <option value="alt_panel">alt_panel</option>
          <option value="ust_panel">ust_panel</option>
          <option value="sol_panel">sol_panel</option>
          <option value="sag_panel">sag_panel</option>
        </select>
      </div>
      <div class="row">
        <label class="mini">Ölçek U</label>
        <input id="uScale" type="range" min="0.1" max="2.5" step="0.01" value="0.35" class="range" />
        <input id="uVal" class="input" style="width:64px" value="0.35" />
      </div>
      <div class="row">
        <label class="mini">Ölçek V</label>
        <input id="vScale" type="range" min="0.1" max="2.5" step="0.01" value="0.35" class="range" />
        <input id="vVal" class="input" style="width:64px" value="0.35" />
      </div>
      <div class="row">
        <label class="mini">Yön (°)</label>
        <input id="rot" type="range" min="0" max="180" step="1" value="0" class="range" />
        <input id="rotVal" class="input" style="width:64px" value="0" />
        <button id="rot90" class="btn">90°</button>
      </div>
      <div class="row">
        <button id="applyTex" class="btn">Bu parçaya uygula</button>
        <button id="copyCfg" class="btn">Ayarları Kopyala</button>
        <button id="resetTex" class="btn">Varsayılan</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js?v=15";
    import { MeshoptDecoder } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/meshopt_decoder.module.js?v=15";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js?v=15";

    // ====== AYARLAR ======
    const MODEL_PATHS = {
      A: "assets/model.glb?v=15",
      B: "assets/model2.glb?v=15"   // ikinci modelini bu adla koy
    };
    const PART_KEYS = {
      alt_panel: ["alt_panel","alt","bottom","base"],
      ust_panel: ["ust_panel","ust","üst","top","kapak"],
      sol_panel: ["sol_panel","sol","left"],
      sag_panel: ["sag_panel","sag","sağ","right"]
    };
    const MATERIAL_TEXTURES = {
      walnut: "textures/walnut.jpg",
      oak:    "textures/oak.jpg",
      white:  "textures/white.jpg"
    };
    const MATERIAL_COLORS = { walnut:0x8b5a2b, oak:0xb88a55, white:0xeeeeee };

// ❶ Parça eşleşmeleri aynı kalsın (PART_KEYS, MATERIAL_* vs. dokunma)

// ❷ Varsayılan doku ayarları (tüm modeller için başlangıç şablonu)
const DEFAULT_TEX_TWEAK = {
  alt_panel: { repeat:[0.35,0.35], rotDeg: 0  },
  ust_panel: { repeat:[0.35,0.35], rotDeg: 0  },
  sol_panel: { repeat:[0.35,0.35], rotDeg: 90 },
  sag_panel: { repeat:[0.35,0.35], rotDeg: 90 }
};

// ❸ MODEL-BAZLI DURUM: her modelin kendi malzeme ve tweak hafızası var
const STATE = {
  A: {
    mat:   { alt_panel:"white", ust_panel:"white", sol_panel:"white", sag_panel:"white" },
    tweak: JSON.parse(JSON.stringify(DEFAULT_TEX_TWEAK))
  },
  B: {
    mat:   { alt_panel:"white", ust_panel:"white", sol_panel:"white", sag_panel:"white" },
    tweak: JSON.parse(JSON.stringify(DEFAULT_TEX_TWEAK))
  }
};


    // ====== DURUM ======
    let scene, camera, renderer, controls, root, currentModel = "A";
    const container = document.getElementById('canvasContainer');
    const diagEl = document.getElementById('diag');
    const partTargets = { alt_panel:[], ust_panel:[], sol_panel:[], sag_panel:[] };
    const CURRENT_MAT = { alt_panel:"white", ust_panel:"white", sol_panel:"white", sag_panel:"white" };
    const log = (m)=>{ diagEl.textContent = m; console.log(m); };

    // UI elemanları (doku paneli)
    const partSel = document.getElementById('partSel');
    const uScale = document.getElementById('uScale'); const uVal = document.getElementById('uVal');
    const vScale = document.getElementById('vScale'); const vVal = document.getElementById('vVal');
    const rot = document.getElementById('rot');       const rotVal = document.getElementById('rotVal');
    const rot90 = document.getElementById('rot90');
    const applyTexBtn = document.getElementById('applyTex');
    const resetTexBtn = document.getElementById('resetTex');
    const copyCfgBtn = document.getElementById('copyCfg');

    // Model butonları
    document.getElementById('modelA').onclick = ()=> switchModel("A");
    document.getElementById('modelB').onclick = ()=> switchModel("B");

    init3D();
    await loadModelFrom(MODEL_PATHS[currentModel]);
    animate();
    syncUIFromState();

    function init3D(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf3f0ea);

      const {w,h} = size();
      camera = new THREE.PerspectiveCamera(50, w/h, 0.01, 5000);
      camera.position.set(0, 1.2, 3);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);

      const d1 = new THREE.DirectionalLight(0xffffff, 1.0);
      d1.position.set(3,4,5);
      scene.add(d1);
      scene.add(new THREE.AmbientLight(0xffffff, 0.55));

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08;
      controls.minDistance = 0.25;   controls.maxDistance = 50;
      controls.zoomSpeed = 1.0;      controls.rotateSpeed = 0.8; controls.panSpeed = 0.6;

      window.addEventListener('resize', onResize);
    }

    function size(){
      const r = container.getBoundingClientRect();
      return { w: r.width || window.innerWidth, h: r.height || (window.innerHeight - 180) };
    }
    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }

async function switchModel(key){
  if (!MODEL_PATHS[key]) { log("Model yolu yok: "+key); return; }
  currentModel = key;
  await loadModelFrom(MODEL_PATHS[key], /*keepView=*/true); // ← kamera sabit
}


async function loadModelFrom(path, keepView=false){
  try{
    log("Model yükleniyor… "+path);

    // KAMERA DURUMUNU KAYDET (gerekirse geri yüklenecek)
    const camPos   = camera.position.clone();
    const camTgt   = controls.target.clone();

    disposeRoot();
    for (const k in partTargets) partTargets[k] = [];

    const loader = new GLTFLoader();
    loader.setMeshoptDecoder(MeshoptDecoder);
    const gltf = await loader.loadAsync(path);

    root = gltf.scene;
    scene.add(root);

    if (keepView){
      // Kamerayı ELLEME, sadece modeli merkeze al
      centerOnly(root);
      camera.position.copy(camPos);
      controls.target.copy(camTgt);
      controls.update();
    } else {
      // İlk yüklemede kadrajla
      centerAndFrame(root);
    }

    // Parçaları topla + malzemeleri klonla
    root.traverse(obj=>{
      if (!obj.isMesh) return;
      const name = (obj.name||"").toLowerCase();
      const matName = (obj.material?.name||"").toLowerCase();
      obj.castShadow = true; obj.receiveShadow = true;
      obj.material = Array.isArray(obj.material) ? obj.material.map(m=>m.clone()) : obj.material.clone();
      for (const key in PART_KEYS){
        if (PART_KEYS[key].some(k=> name.includes(k) || matName.includes(k))) partTargets[key].push(obj);
      }
    });

    // Başlangıç: beyaz + doku parametreleri
// ❹ Bu model için ÖNCEDEN kaydedilmiş malzeme/tweak'leri uygula
for (const p of Object.keys(partTargets)){
  const savedMat = STATE[currentModel].mat[p] || "white";
  // malzemeyi uygula (onlyTex=false), ardından tweak zaten applyPart içinde uygulanacak
  await applyPart(p, savedMat, /*onlyTex=*/false);
}


    log("Hazır. ("+keyLabel(currentModel)+")");
  }catch(e){ log("MODEL YÜKLENEMEDİ → "+e.message); }
}


    function keyLabel(k){ return k==="A"?"Model A":"Model B"; }

    function disposeRoot(){
      if (!root) return;
      scene.remove(root);
      root.traverse(obj=>{
        if (obj.isMesh){
          if (obj.geometry) obj.geometry.dispose();
          const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
          mats.forEach(m=>{
            if (!m) return;
            ["map","normalMap","roughnessMap","metalnessMap","aoMap","emissiveMap"].forEach(k=>{
              if (m[k]) { m[k].dispose(); }
            });
            m.dispose();
          });
        }
      });
      root = null;
    }

    function centerAndFrame(object){
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = (maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2))) * 1.6;
      camera.position.set(0,0,dist);
      camera.near = dist/50; camera.far = dist*50; camera.updateProjectionMatrix();
      controls.target.set(0,0,0); controls.update();
    }
    function centerOnly(object){
  const box = new THREE.Box3().setFromObject(object);
  const center = box.getCenter(new THREE.Vector3());
  object.position.sub(center);
}

    function onResize(){ const {w,h}=size(); camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); controls.update(); }

    // --- Doku yükleyici ---
    const textureCache = new Map();
    function loadTexture(url){
      return new Promise((resolve,reject)=>{
        if (textureCache.has(url)) return resolve(textureCache.get(url));
        new THREE.TextureLoader().load(url, tx=>{
          tx.colorSpace = THREE.SRGBColorSpace;
          tx.wrapS = THREE.RepeatWrapping; tx.wrapT = THREE.RepeatWrapping;
          tx.center.set(0.5,0.5);
          tx.repeat.set(1,1);
          tx.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy()||8);
          textureCache.set(url, tx); resolve(tx);
        }, undefined, ()=>reject(new Error("Doku yüklenemedi: "+url)));
      });
    }
    async function buildMaterialFromKey(key){
      const path = MATERIAL_TEXTURES[key];
      if (path){
        try{ const tx = await loadTexture(path);
          return new THREE.MeshStandardMaterial({ map: tx, roughness:0.6, metalness:0.05 });
        }catch(e){ log(e.message+" → renk fallback"); }
      }
      const color = MATERIAL_COLORS[key]||0xcccccc;
      return new THREE.MeshStandardMaterial({ color, roughness:0.6, metalness:0.05 });
    }
async function applyPart(partKey, matKey, onlyTex=false){
  const targets = partTargets[partKey] || [];
  if (!targets.length){ log(partKey+" için mesh bulunamadı."); return; }

  if (!onlyTex){
    const mat = await buildMaterialFromKey(matKey);
    targets.forEach(m => { m.material = mat; m.material.needsUpdate = true; });
    // aktif modelin malzeme hafızasını güncelle
    STATE[currentModel].mat[partKey] = matKey;
  }

  applyTexParams(partKey);

  const t = STATE[currentModel].tweak[partKey];
  const m = STATE[currentModel].mat[partKey];
  log(`${partKey} → ${m} | U:${t.repeat[0]} V:${t.repeat[1]} R:${t.rotDeg}° (model ${currentModel})`);
}

function applyTexParams(partKey){
  const targets = partTargets[partKey] || [];
  const cfg = STATE[currentModel].tweak[partKey];
  targets.forEach(m=>{
    const mats = Array.isArray(m.material) ? m.material : [m.material];
    mats.forEach(mat=>{
      if (!mat.map) return;
      mat.map = mat.map.clone();
      mat.map.repeat.set(cfg.repeat[0], cfg.repeat[1]);
      mat.map.center.set(0.5,0.5);
      mat.map.rotation = (cfg.rotDeg * Math.PI) / 180;
      mat.map.needsUpdate = true;
    });
  });
}


    // === Parça butonları & UID örneği ===
    document.querySelectorAll('button[data-part]').forEach(btn=>{
      btn.addEventListener('click', ()=> applyPart(btn.dataset.part, btn.dataset.mat));
    });
    document.getElementById('applyUid').addEventListener('click', ()=>{
      const uid = document.getElementById('uidInput').value.trim();
      if (!uid) return;
      // Örnek UID eşleştirmesi:
      const map = {
        "0001234567": { alt_panel:"walnut" },
        "0002345678": { ust_panel:"oak"    },
        "0003456789": { sol_panel:"white", sag_panel:"walnut" }
      };
      const choices = map[uid];
      if (choices){
        for (const part in choices) applyPart(part, choices[part]);
      } else {
        log("UID tanımsız: "+uid);
      }
    });

    // Dinamik doku paneli (mevcut)
function syncUIFromState(){
  const p = partSel.value;
  const t = STATE[currentModel].tweak[p];
  uScale.value = uVal.value = t.repeat[0];
  vScale.value = vVal.value = t.repeat[1];
  rot.value    = rotVal.value = t.rotDeg;
}
    
function readUIToState(){
  const p = partSel.value;
  const repU = clamp(parseFloat(uVal.value), 0.1, 2.5);
  const repV = clamp(parseFloat(vVal.value), 0.1, 2.5);
  const rdeg = clamp(parseInt(rotVal.value||"0",10), 0, 180);
  STATE[currentModel].tweak[p] = { repeat:[repU,repV], rotDeg:rdeg };
}
    function clamp(v,min,max){ return isNaN(v)?min:Math.max(min,Math.min(max,v)); }
    [uScale,vScale,rot].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        if (inp===uScale) uVal.value = inp.value;
        if (inp===vScale) vVal.value = inp.value;
        if (inp===rot)    rotVal.value = inp.value;
        readUIToState(); applyTexParams(partSel.value);
      });
    });
    [uVal,vVal,rotVal].forEach(inp=>{
      inp.addEventListener('change', ()=>{ readUIToState(); applyTexParams(partSel.value); syncUIFromState(); });
    });
    partSel.addEventListener('change', syncUIFromState);
    document.getElementById('rot90').addEventListener('click', ()=>{
      rot.value=rotVal.value= (parseInt(rotVal.value,10)===90?0:90);
      readUIToState(); applyTexParams(partSel.value);
    });
    document.getElementById('applyTex').addEventListener('click', ()=>{
      applyPart(partSel.value, CURRENT_MAT[partSel.value], /*onlyTex=*/true);
    });
document.getElementById('resetTex').addEventListener('click', ()=>{
  const p = partSel.value;
  const def = DEFAULT_TEX_TWEAK[p];
  STATE[currentModel].tweak[p] = { repeat:[...def.repeat], rotDeg:def.rotDeg };
  syncUIFromState();
  applyTexParams(p);
});

    document.getElementById('copyCfg').addEventListener('click', async ()=>{
      const txt = JSON.stringify(TEX_TWEAK, null, 2);
      try{ await navigator.clipboard.writeText(txt); log("Ayarlar panoya kopyalandı."); }
      catch{ console.log(txt); log("Kopyalanamadı, konsola yazıldı."); }
    });
  </script>
</body>
</html>


